{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nexports.__esModule = true;\nexports[\"default\"] = void 0;\nvar _url = require(\"url\");\nvar _mitt = _interopRequireDefault(require(\"../next-server/lib/mitt\"));\nvar _isDynamic = require(\"./../next-server/lib/router/utils/is-dynamic\");\nvar _routeMatcher = require(\"./../next-server/lib/router/utils/route-matcher\");\nvar _routeRegex = require(\"./../next-server/lib/router/utils/route-regex\");\nfunction hasRel(rel, link) {\n  try {\n    link = document.createElement('link');\n    return link.relList.supports(rel);\n  } catch (_unused) {}\n}\nvar relPrefetch = hasRel('preload') && !hasRel('prefetch') ?\n// https://caniuse.com/#feat=link-rel-preload\n// macOS and iOS (Safari does not support prefetch)\n'preload' :\n// https://caniuse.com/#feat=link-rel-prefetch\n// IE 11, Edge 12+, nearly all evergreen\n'prefetch';\nvar hasNoModule = 'noModule' in document.createElement('script'); /** @param {string} route */\nfunction normalizeRoute(route) {\n  if (route[0] !== '/') {\n    throw new Error(\"Route name should start with a \\\"/\\\", got \\\"\" + route + \"\\\"\");\n  }\n  route = route.replace(/\\/index$/, '/');\n  if (route === '/') return route;\n  return route.replace(/\\/$/, '');\n}\nfunction appendLink(href, rel, as) {\n  return new Promise(function (res, rej, link) {\n    link = document.createElement('link');\n    link.crossOrigin = process.crossOrigin;\n    link.href = href;\n    link.rel = rel;\n    if (as) link.as = as;\n    link.onload = res;\n    link.onerror = rej;\n    document.head.appendChild(link);\n  });\n}\nvar PageLoader = /*#__PURE__*/function () {\n  function PageLoader(buildId, assetPrefix) {\n    _classCallCheck(this, PageLoader);\n    this.buildId = buildId;\n    this.assetPrefix = assetPrefix;\n    this.pageCache = {};\n    this.pageRegisterEvents = (0, _mitt[\"default\"])();\n    this.loadingRoutes = {};\n    if (process.env.__NEXT_GRANULAR_CHUNKS) {\n      this.promisedBuildManifest = new Promise(function (resolve) {\n        if (window.__BUILD_MANIFEST) {\n          resolve(window.__BUILD_MANIFEST);\n        } else {\n          window.__BUILD_MANIFEST_CB = function () {\n            resolve(window.__BUILD_MANIFEST);\n          };\n        }\n      });\n    } /** @type {Promise<Set<string>>} */\n    this.promisedSsgManifest = new Promise(function (resolve) {\n      if (window.__SSG_MANIFEST) {\n        resolve(window.__SSG_MANIFEST);\n      } else {\n        window.__SSG_MANIFEST_CB = function () {\n          resolve(window.__SSG_MANIFEST);\n        };\n      }\n    });\n  } // Returns a promise for the dependencies for a particular route\n  return _createClass(PageLoader, [{\n    key: \"getDependencies\",\n    value: function getDependencies(route) {\n      var _this = this;\n      return this.promisedBuildManifest.then(function (man) {\n        return man[route] && man[route].map(function (url) {\n          return _this.assetPrefix + \"/_next/\" + encodeURI(url);\n        }) || [];\n      });\n    } /**\n      * @param {string} href the route href (file-system path)\n      * @param {string} asPath the URL as shown in browser (virtual path); used for dynamic routes\n      */\n  }, {\n    key: \"getDataHref\",\n    value: function getDataHref(href, asPath) {\n      var _this2 = this;\n      var getHrefForSlug = /** @type string */function getHrefForSlug(path) {\n        return _this2.assetPrefix + \"/_next/data/\" + _this2.buildId + (path === '/' ? '/index' : path) + \".json\";\n      };\n      var _ref2 = (0, _url.parse)(href, true),\n        hrefPathname = _ref2.pathname,\n        query = _ref2.query;\n      var _ref3 = (0, _url.parse)(asPath),\n        asPathname = _ref3.pathname;\n      var route = normalizeRoute(hrefPathname);\n      var isDynamic = (0, _isDynamic.isDynamicRoute)(route),\n        interpolatedRoute;\n      if (isDynamic) {\n        var dynamicRegex = (0, _routeRegex.getRouteRegex)(route);\n        var dynamicGroups = dynamicRegex.groups;\n        var dynamicMatches =\n        // Try to match the dynamic route against the asPath\n        (0, _routeMatcher.getRouteMatcher)(dynamicRegex)(asPathname) ||\n        // Fall back to reading the values from the href\n        // TODO: should this take priority; also need to change in the router.\n        query;\n        interpolatedRoute = route;\n        if (!Object.keys(dynamicGroups).every(function (param) {\n          var value = dynamicMatches[param];\n          var repeat = dynamicGroups[param].repeat; // support single-level catch-all\n          // TODO: more robust handling for user-error (passing `/`)\n          if (repeat && !Array.isArray(value)) value = [value];\n          return param in dynamicMatches && (\n          // Interpolate group into data URL if present\n          interpolatedRoute = interpolatedRoute.replace(\"[\" + (repeat ? '...' : '') + param + \"]\", repeat ? value.map(encodeURIComponent).join('/') : encodeURIComponent(value)));\n        })) {\n          interpolatedRoute = ''; // did not satisfy all requirements\n          // n.b. We ignore this error because we handle warning for this case in\n          // development in the `<Link>` component directly.\n        }\n      }\n      return isDynamic ? interpolatedRoute && getHrefForSlug(interpolatedRoute) : getHrefForSlug(route);\n    } /**\n      * @param {string} href the route href (file-system path)\n      * @param {string} asPath the URL as shown in browser (virtual path); used for dynamic routes\n      */\n  }, {\n    key: \"prefetchData\",\n    value: function prefetchData(href, asPath) {\n      var _this3 = this;\n      var _ref4 = (0, _url.parse)(href, true),\n        hrefPathname = _ref4.pathname;\n      var route = normalizeRoute(hrefPathname);\n      return this.promisedSsgManifest.then(function (s, _dataHref) {\n        return (\n          // Check if the route requires a data file\n          s.has(route) && (\n          // Try to generate data href, noop when falsy\n          _dataHref = _this3.getDataHref(href, asPath)) &&\n          // noop when data has already been prefetched (dedupe)\n          !document.querySelector(\"link[rel=\\\"\" + relPrefetch + \"\\\"][href^=\\\"\" + _dataHref + \"\\\"]\") &&\n          // Inject the `<link rel=prefetch>` tag for above computed `href`.\n          appendLink(_dataHref, relPrefetch, 'fetch')\n        );\n      });\n    }\n  }, {\n    key: \"loadPage\",\n    value: function loadPage(route) {\n      return this.loadPageScript(route);\n    }\n  }, {\n    key: \"loadPageScript\",\n    value: function loadPageScript(route) {\n      var _this4 = this;\n      route = normalizeRoute(route);\n      return new Promise(function (resolve, reject) {\n        var _fire = function fire(_ref) {\n          var error = _ref.error,\n            page = _ref.page,\n            mod = _ref.mod;\n          _this4.pageRegisterEvents.off(route, _fire);\n          delete _this4.loadingRoutes[route];\n          if (error) {\n            reject(error);\n          } else {\n            resolve({\n              page: page,\n              mod: mod\n            });\n          }\n        }; // If there's a cached version of the page, let's use it.\n        var cachedPage = _this4.pageCache[route];\n        if (cachedPage) {\n          var error = cachedPage.error,\n            page = cachedPage.page,\n            mod = cachedPage.mod;\n          error ? reject(error) : resolve({\n            page: page,\n            mod: mod\n          });\n          return;\n        } // Register a listener to get the page\n        _this4.pageRegisterEvents.on(route, _fire); // If the page is loading via SSR, we need to wait for it\n        // rather downloading it again.\n        if (document.querySelector(\"script[data-next-page=\\\"\" + route + \"\\\"]\")) {\n          return;\n        }\n        if (!_this4.loadingRoutes[route]) {\n          _this4.loadingRoutes[route] = true;\n          if (process.env.__NEXT_GRANULAR_CHUNKS) {\n            _this4.getDependencies(route).then(function (deps) {\n              deps.forEach(function (d) {\n                if (/\\.js$/.test(d) && !document.querySelector(\"script[src^=\\\"\" + d + \"\\\"]\")) {\n                  _this4.loadScript(d, route, false);\n                }\n                if (/\\.css$/.test(d) && !document.querySelector(\"link[rel=stylesheet][href^=\\\"\" + d + \"\\\"]\")) {\n                  appendLink(d, 'stylesheet')[\"catch\"](function () {// FIXME: handle failure\n                    // Right now, this is needed to prevent an unhandled rejection.\n                  });\n                }\n              });\n              _this4.loadRoute(route);\n            });\n          } else {\n            _this4.loadRoute(route);\n          }\n        }\n      });\n    }\n  }, {\n    key: \"loadRoute\",\n    value: function loadRoute(route) {\n      route = normalizeRoute(route);\n      var scriptRoute = route === '/' ? '/index.js' : route + \".js\";\n      var url = this.assetPrefix + \"/_next/static/\" + encodeURIComponent(this.buildId) + \"/pages\" + encodeURI(scriptRoute);\n      this.loadScript(url, route, true);\n    }\n  }, {\n    key: \"loadScript\",\n    value: function loadScript(url, route, isPage) {\n      var _this5 = this;\n      var script = document.createElement('script');\n      if (process.env.__NEXT_MODERN_BUILD && hasNoModule) {\n        script.type = 'module'; // Only page bundle scripts need to have .module added to url,\n        // dependencies already have it added during build manifest creation\n        if (isPage) url = url.replace(/\\.js$/, '.module.js');\n      }\n      script.crossOrigin = process.crossOrigin;\n      script.src = url;\n      script.onerror = function () {\n        var error = new Error(\"Error loading script \" + url);\n        error.code = 'PAGE_LOAD_ERROR';\n        _this5.pageRegisterEvents.emit(route, {\n          error: error\n        });\n      };\n      document.body.appendChild(script);\n    } // This method if called by the route code.\n  }, {\n    key: \"registerPage\",\n    value: function registerPage(route, regFn) {\n      var _this6 = this;\n      var register = function register() {\n        try {\n          var mod = regFn();\n          var pageData = {\n            page: mod[\"default\"] || mod,\n            mod: mod\n          };\n          _this6.pageCache[route] = pageData;\n          _this6.pageRegisterEvents.emit(route, pageData);\n        } catch (error) {\n          _this6.pageCache[route] = {\n            error: error\n          };\n          _this6.pageRegisterEvents.emit(route, {\n            error: error\n          });\n        }\n      };\n      if (false) {\n        // Wait for webpack to become idle if it's not.\n        // More info: https://github.com/zeit/next.js/pull/1511\n        if (module.hot && module.hot.status() !== 'idle') {\n          console.log(\"Waiting for webpack to become \\\"idle\\\" to initialize the page: \\\"\" + route + \"\\\"\");\n          var _check = function check(status) {\n            if (status === 'idle') {\n              module.hot.removeStatusHandler(_check);\n              register();\n            }\n          };\n          module.hot.status(_check);\n          return;\n        }\n      }\n      register();\n    } /**\n      * @param {string} route\n      * @param {boolean} [isDependency]\n      */\n  }, {\n    key: \"prefetch\",\n    value: function prefetch(route, isDependency) {\n      var _this7 = this;\n      // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118\n      // License: Apache 2.0\n      var cn;\n      if (cn = navigator.connection) {\n        // Don't prefetch if using 2G or if Save-Data is enabled.\n        if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve();\n      } /** @type {string} */\n      var url;\n      if (isDependency) {\n        url = route;\n      } else {\n        route = normalizeRoute(route);\n        var scriptRoute = (route === '/' ? '/index' : route) + \".js\";\n        if (process.env.__NEXT_MODERN_BUILD && hasNoModule) {\n          scriptRoute = scriptRoute.replace(/\\.js$/, '.module.js');\n        }\n        url = this.assetPrefix + \"/_next/static/\" + encodeURIComponent(this.buildId) + \"/pages\" + encodeURI(scriptRoute);\n      }\n      return Promise.all(document.querySelector(\"link[rel=\\\"\" + relPrefetch + \"\\\"][href^=\\\"\" + url + \"\\\"], script[data-next-page=\\\"\" + route + \"\\\"]\") ? [] : [appendLink(url, relPrefetch, url.match(/\\.css$/) ? 'style' : 'script'), process.env.__NEXT_GRANULAR_CHUNKS && !isDependency && this.getDependencies(route).then(function (urls) {\n        return Promise.all(urls.map(function (url) {\n          return _this7.prefetch(url, true);\n        }));\n      })]).then(\n      // do not return any data\n      function () {},\n      // swallow prefetch errors\n      function () {});\n    }\n  }]);\n}();\nexports[\"default\"] = PageLoader;","map":null,"metadata":{},"sourceType":"script"}